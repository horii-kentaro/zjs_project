"""
Database vulnerability service for data persistence.

This service provides database operations for vulnerability data management,
including search, filtering, sorting, and UPSERT operations.
"""

import logging
from typing import Optional

from sqlalchemy import case, or_
from sqlalchemy.dialects.postgresql import insert
from sqlalchemy.exc import IntegrityError, SQLAlchemyError
from sqlalchemy.orm import Session

from src.models.vulnerability import Vulnerability
from src.schemas.vulnerability import (
    VulnerabilityCreate,
    VulnerabilityListResponse,
    VulnerabilityResponse,
)

logger = logging.getLogger(__name__)


class DatabaseVulnerabilityService:
    """
    Database service for vulnerability data management.

    This service handles all database operations for vulnerability data,
    including:
    - Search and filtering with pagination
    - Sorting (with custom severity sorting)
    - UPSERT operations with idempotency guarantee
    - Transaction management with proper error handling
    """

    def __init__(self, db: Session):
        """
        Initialize database service.

        Args:
            db: SQLAlchemy database session
        """
        self.db = db
        logger.debug("DatabaseVulnerabilityService initialized")

    def search_vulnerabilities(
        self,
        page: int = 1,
        page_size: int = 50,
        sort_by: str = "modified_date",
        sort_order: str = "desc",
        search: Optional[str] = None,
    ) -> VulnerabilityListResponse:
        """
        Search and filter vulnerability data with pagination.

        Args:
            page: Page number (1-indexed)
            page_size: Number of items per page (1-100)
            sort_by: Sort field (published_date, modified_date, severity, cvss_score)
            sort_order: Sort order (asc or desc)
            search: Search keyword (CVE ID or title partial match)

        Returns:
            VulnerabilityListResponse: Paginated vulnerability list

        Raises:
            SQLAlchemyError: Database query error
        """
        try:
            logger.info(
                f"Searching vulnerabilities: page={page}, page_size={page_size}, "
                f"sort_by={sort_by}, sort_order={sort_order}, search={search}"
            )

            # Start with base query
            query = self.db.query(Vulnerability)

            # Apply search filter (CVE ID or title partial match)
            if search:
                search_pattern = f"%{search}%"
                query = query.filter(
                    or_(
                        Vulnerability.cve_id.ilike(search_pattern),
                        Vulnerability.title.ilike(search_pattern),
                    )
                )
                logger.debug(f"Applied search filter: {search}")

            # Apply sorting
            query = self._apply_sorting(query, sort_by, sort_order)

            # Get total count before pagination
            total = query.count()
            logger.debug(f"Total records found: {total}")

            # Apply pagination
            offset = (page - 1) * page_size
            items = query.offset(offset).limit(page_size).all()

            # Calculate total pages
            total_pages = (total + page_size - 1) // page_size

            logger.info(f"Returning page {page}/{total_pages} with {len(items)} items (total: {total})")

            # Convert SQLAlchemy models to Pydantic schemas
            response_items = [VulnerabilityResponse.model_validate(item) for item in items]

            return VulnerabilityListResponse(
                items=response_items,
                total=total,
                page=page,
                page_size=page_size,
                total_pages=total_pages,
            )

        except SQLAlchemyError as e:
            logger.error(f"Database query error in search_vulnerabilities: {e}", exc_info=True)
            raise

    def _apply_sorting(self, query, sort_by: str, sort_order: str):
        """
        Apply sorting to query with custom severity ordering.

        Args:
            query: SQLAlchemy query object
            sort_by: Sort field (published_date, modified_date, severity, cvss_score)
            sort_order: Sort order (asc or desc)

        Returns:
            SQLAlchemy query with sorting applied
        """
        if sort_by == "severity":
            # Custom severity sorting: Critical > High > Medium > Low > None
            severity_order = case(
                (Vulnerability.severity == "Critical", 1),
                (Vulnerability.severity == "High", 2),
                (Vulnerability.severity == "Medium", 3),
                (Vulnerability.severity == "Low", 4),
                else_=5,
            )

            if sort_order == "desc":
                query = query.order_by(severity_order.asc())
            else:
                query = query.order_by(severity_order.desc())

            logger.debug(f"Applied custom severity sorting: {sort_order}")
        else:
            # Standard column sorting
            order_column = getattr(Vulnerability, sort_by)
            if sort_order == "desc":
                query = query.order_by(order_column.desc())
            else:
                query = query.order_by(order_column.asc())

            logger.debug(f"Applied standard sorting: {sort_by} {sort_order}")

        return query

    def get_vulnerability_by_cve_id(self, cve_id: str) -> Optional[VulnerabilityResponse]:
        """
        Get vulnerability by CVE ID.

        Args:
            cve_id: CVE identifier (e.g., CVE-2024-0001)

        Returns:
            Optional[VulnerabilityResponse]: Vulnerability data or None if not found

        Raises:
            SQLAlchemyError: Database query error
        """
        try:
            logger.info(f"Fetching vulnerability: {cve_id}")

            vulnerability = self.db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).first()

            if vulnerability:
                logger.info(f"Found vulnerability: {cve_id}")
                return VulnerabilityResponse.model_validate(vulnerability)
            else:
                logger.warning(f"Vulnerability not found: {cve_id}")
                return None

        except SQLAlchemyError as e:
            logger.error(f"Database query error in get_vulnerability_by_cve_id: {e}", exc_info=True)
            raise

    def upsert_vulnerability(self, vulnerability_data: VulnerabilityCreate) -> VulnerabilityResponse:
        """
        Insert or update vulnerability with idempotency guarantee.

        Uses PostgreSQL's ON CONFLICT DO UPDATE for idempotent UPSERT operation.
        This ensures that the same data can be inserted multiple times without
        causing data inconsistencies.

        Args:
            vulnerability_data: Vulnerability data to insert/update

        Returns:
            VulnerabilityResponse: Inserted or updated vulnerability data

        Raises:
            SQLAlchemyError: Database operation error
        """
        try:
            logger.info(f"UPSERT vulnerability: {vulnerability_data.cve_id}")

            # Convert Pydantic model to dict
            data_dict = vulnerability_data.model_dump()

            # PostgreSQL UPSERT statement
            stmt = insert(Vulnerability).values(**data_dict)

            # ON CONFLICT DO UPDATE: update all fields except cve_id and created_at
            update_dict = {key: value for key, value in data_dict.items() if key not in ["cve_id", "created_at"]}

            stmt = stmt.on_conflict_do_update(
                index_elements=["cve_id"],  # Primary key
                set_=update_dict,
            )

            # Execute UPSERT
            self.db.execute(stmt)
            self.db.commit()

            logger.info(f"UPSERT completed: {vulnerability_data.cve_id}")

            # Fetch and return the inserted/updated record
            result = self.get_vulnerability_by_cve_id(vulnerability_data.cve_id)

            if result is None:
                raise SQLAlchemyError(f"UPSERT succeeded but record not found: {vulnerability_data.cve_id}")

            return result

        except IntegrityError as e:
            logger.error(f"Integrity error in upsert_vulnerability: {e}", exc_info=True)
            self.db.rollback()
            raise
        except SQLAlchemyError as e:
            logger.error(f"Database error in upsert_vulnerability: {e}", exc_info=True)
            self.db.rollback()
            raise

    def upsert_vulnerabilities_batch(self, vulnerabilities_data: list[VulnerabilityCreate]) -> dict[str, int]:
        """
        Batch UPSERT vulnerabilities with transaction management.

        All operations are performed in a single transaction.
        If any operation fails, all changes are rolled back.

        Args:
            vulnerabilities_data: List of vulnerability data to insert/update

        Returns:
            dict: Statistics with keys 'inserted', 'updated', 'failed'

        Raises:
            SQLAlchemyError: Database operation error (with automatic rollback)
        """
        stats = {"inserted": 0, "updated": 0, "failed": 0}

        try:
            logger.info(f"Batch UPSERT: {len(vulnerabilities_data)} vulnerabilities")

            for vuln_data in vulnerabilities_data:
                try:
                    # Check if record exists
                    existing = self.db.query(Vulnerability).filter(Vulnerability.cve_id == vuln_data.cve_id).first()

                    # Perform UPSERT
                    data_dict = vuln_data.model_dump()
                    stmt = insert(Vulnerability).values(**data_dict)

                    update_dict = {
                        key: value for key, value in data_dict.items() if key not in ["cve_id", "created_at"]
                    }

                    stmt = stmt.on_conflict_do_update(index_elements=["cve_id"], set_=update_dict)

                    self.db.execute(stmt)

                    # Track statistics
                    if existing:
                        stats["updated"] += 1
                    else:
                        stats["inserted"] += 1

                except Exception as e:
                    logger.error(f"Failed to UPSERT {vuln_data.cve_id}: {e}")
                    stats["failed"] += 1
                    raise  # Re-raise to trigger rollback

            # Commit all changes
            self.db.commit()

            logger.info(
                f'Batch UPSERT completed: inserted={stats["inserted"]}, '
                f'updated={stats["updated"]}, failed={stats["failed"]}'
            )

            return stats

        except SQLAlchemyError as e:
            logger.error(f"Batch UPSERT failed, rolling back: {e}", exc_info=True)
            self.db.rollback()
            raise

    def delete_vulnerability(self, cve_id: str) -> bool:
        """
        Delete vulnerability by CVE ID.

        Args:
            cve_id: CVE identifier

        Returns:
            bool: True if deleted, False if not found

        Raises:
            SQLAlchemyError: Database operation error
        """
        try:
            logger.info(f"Deleting vulnerability: {cve_id}")

            result = self.db.query(Vulnerability).filter(Vulnerability.cve_id == cve_id).delete()

            self.db.commit()

            if result > 0:
                logger.info(f"Deleted vulnerability: {cve_id}")
                return True
            else:
                logger.warning(f"Vulnerability not found for deletion: {cve_id}")
                return False

        except SQLAlchemyError as e:
            logger.error(f"Database error in delete_vulnerability: {e}", exc_info=True)
            self.db.rollback()
            raise

    def get_latest_modified_date(self) -> Optional[str]:
        """
        Get the latest modified_date from the database.

        Used for differential data fetching from JVN iPedia API.

        Returns:
            Optional[str]: Latest modified date in ISO 8601 format, or None if no records

        Raises:
            SQLAlchemyError: Database query error
        """
        try:
            logger.debug("Fetching latest modified_date")

            result = self.db.query(Vulnerability.modified_date).order_by(Vulnerability.modified_date.desc()).first()

            if result:
                latest_date = result[0].isoformat()
                logger.info(f"Latest modified_date: {latest_date}")
                return latest_date
            else:
                logger.info("No records found, returning None")
                return None

        except SQLAlchemyError as e:
            logger.error(f"Database error in get_latest_modified_date: {e}", exc_info=True)
            raise

    def get_all_cve_ids(self) -> set[str]:
        """
        Get all CVE IDs currently in the database.

        Returns:
            set[str]: Set of CVE IDs

        Raises:
            SQLAlchemyError: Database query error
        """
        try:
            logger.debug("Fetching all CVE IDs from database")

            results = self.db.query(Vulnerability.cve_id).all()
            cve_ids = {row[0] for row in results}

            logger.info(f"Found {len(cve_ids)} unique CVE IDs in database")
            return cve_ids

        except SQLAlchemyError as e:
            logger.error(f"Database error in get_all_cve_ids: {e}", exc_info=True)
            raise
